
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://tang-jiapeng.github.io/core/csapp/ch12/">
      
      
        <link rel="prev" href="../ch11/">
      
      
        <link rel="next" href="../../cmu10-714/lecture2/">
      
      
      <link rel="icon" href="../../../logo.ico">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.31">
    
    
      
        <title>Chapter12：并发编程 - 0X10CC's notes</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.3cba04c6.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Noto Serif SC";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../css/timeago.css">
    
      <link rel="stylesheet" href="../../../from_oi_wiki/css/extra.css?v=13">
    
      <link rel="stylesheet" href="../../../css/status.css">
    
      <link rel="stylesheet" href="../../../css/neoteroi-mkdocs.css">
    
      <link rel="stylesheet" href="../../../termynal.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  

<script id="__analytics">function __md_analytics(){function n(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],n("js",new Date),n("config","G-JT9BRCXKJJ"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){this.value&&n("event","search",{search_term:this.value})}),document$.subscribe(function(){var a=document.forms.feedback;if(void 0!==a)for(var e of a.querySelectorAll("[type=submit]"))e.addEventListener("click",function(e){e.preventDefault();var t=document.location.pathname,e=this.getAttribute("data-md-value");n("event","feedback",{page:t,data:e}),a.firstElementChild.disabled=!0;e=a.querySelector(".md-feedback__note [data-md-value='"+e+"']");e&&(e.hidden=!1)}),a.hidden=!1}),location$.subscribe(function(e){n("config","G-JT9BRCXKJJ",{page_path:e.pathname})})});var e=document.createElement("script");e.async=!0,e.src="https://www.googletagmanager.com/gtag/js?id=G-JT9BRCXKJJ",document.getElementById("__analytics").insertAdjacentElement("afterEnd",e)}</script>
  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="cyan">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#并发编程" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="0X10CC&#39;s notes" class="md-header__button md-logo" aria-label="0X10CC's notes" data-md-component="logo">
      
  <img src="../../../logo.ico" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            0X10CC's notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chapter12：并发编程
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="cyan"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="orange"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/tang-jiapeng/tang-jiapeng.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    tang-jiapeng.github.io
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../.." class="md-tabs__link">
          
  
    
  
  🏡 Home

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../langs/" class="md-tabs__link">
          
  
    
  
  Langs

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../" class="md-tabs__link">
          
  
    
  
  Core

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../tools/" class="md-tabs__link">
          
  
    
  
  Tools

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../life/" class="md-tabs__link">
          
  
    
  
  Life

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="0X10CC&#39;s notes" class="md-nav__button md-logo" aria-label="0X10CC's notes" data-md-component="logo">
      
  <img src="../../../logo.ico" alt="logo">

    </a>
    0X10CC's notes
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/tang-jiapeng/tang-jiapeng.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    tang-jiapeng.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../.." class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    🏡 Home
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            🏡 Home
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../langs/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Langs
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Langs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    C++零碎杂记
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            C++零碎杂记
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/%E9%9B%B6%E7%A2%8E%E6%9D%82%E8%AE%B0/%E9%A1%B6%E5%B1%82const%E4%B8%8E%E5%BA%95%E5%B1%82const/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    顶层const与底层const
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/%E9%9B%B6%E7%A2%8E%E6%9D%82%E8%AE%B0/%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    值类型与右值引用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/%E9%9B%B6%E7%A2%8E%E6%9D%82%E8%AE%B0/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数组指针与函数指针
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/%E9%9B%B6%E7%A2%8E%E6%9D%82%E8%AE%B0/C%2B%2B%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++类对象布局
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/%E9%9B%B6%E7%A2%8E%E6%9D%82%E8%AE%B0/C%2B%2B%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E4%B8%8ERTTI/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++中的多态与RTTI
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Effective Modern C++
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            Effective Modern C++
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/effective/item1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    item1：理解模板类型推导
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/effective/item2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    item2：理解auto类型推导
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/effective/item3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    item3：理解decltype
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/effective/item7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    item7：区别使用()和{}创建对象
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/effective/item9/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    item9：优先考虑别名声明而非typedef
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../langs/cpp/effective/item23/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    item23：理解std::move和std::forward
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Core
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Core
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" checked>
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CMU15-213：CSAPP
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            CMU15-213：CSAPP
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch1/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter1：计算机系统漫游
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter2：信息的表示和处理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter3：程序的机器级表示
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter4：处理器体系结构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter5：优化程序性能
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter6：存储器层次结构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter7：链接
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter8：异常控制流
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch9/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter9：虚拟内存
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch10/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter10：系统级I/O
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ch11/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chapter11：网络编程
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Chapter12：并发编程
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Chapter12：并发编程
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#使用进程实现并发" class="md-nav__link">
    <span class="md-ellipsis">
      使用进程实现并发
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用进程实现并发">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#基于进程的并发服务器" class="md-nav__link">
    <span class="md-ellipsis">
      基于进程的并发服务器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#进程的优缺点" class="md-nav__link">
    <span class="md-ellipsis">
      进程的优缺点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#使用-io-多路复用实现并发" class="md-nav__link">
    <span class="md-ellipsis">
      使用 I/O 多路复用实现并发
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用 I/O 多路复用实现并发">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#基于-io-多路复用的并发服务器" class="md-nav__link">
    <span class="md-ellipsis">
      基于 I/O 多路复用的并发服务器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io-多路复用的优缺点" class="md-nav__link">
    <span class="md-ellipsis">
      I/O 多路复用的优缺点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#使用线程实现并发" class="md-nav__link">
    <span class="md-ellipsis">
      使用线程实现并发
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用线程实现并发">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#线程执行模型" class="md-nav__link">
    <span class="md-ellipsis">
      线程执行模型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#posix-线程" class="md-nav__link">
    <span class="md-ellipsis">
      Posix 线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#创建线程" class="md-nav__link">
    <span class="md-ellipsis">
      创建线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#终止线程" class="md-nav__link">
    <span class="md-ellipsis">
      终止线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#回收线程" class="md-nav__link">
    <span class="md-ellipsis">
      回收线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#分离线程" class="md-nav__link">
    <span class="md-ellipsis">
      分离线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#初始化线程" class="md-nav__link">
    <span class="md-ellipsis">
      初始化线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#基于线程的并发服务器" class="md-nav__link">
    <span class="md-ellipsis">
      基于线程的并发服务器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#线程程序中的共享变量" class="md-nav__link">
    <span class="md-ellipsis">
      线程程序中的共享变量
    </span>
  </a>
  
    <nav class="md-nav" aria-label="线程程序中的共享变量">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#线程内存模型" class="md-nav__link">
    <span class="md-ellipsis">
      线程内存模型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#将变量映射到内存" class="md-nav__link">
    <span class="md-ellipsis">
      将变量映射到内存
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#共享变量" class="md-nav__link">
    <span class="md-ellipsis">
      共享变量
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#使用信号量同步线程" class="md-nav__link">
    <span class="md-ellipsis">
      使用信号量同步线程
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用信号量同步线程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#进度图" class="md-nav__link">
    <span class="md-ellipsis">
      进度图
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#信号量" class="md-nav__link">
    <span class="md-ellipsis">
      信号量
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#使用信号量实现互斥" class="md-nav__link">
    <span class="md-ellipsis">
      使用信号量实现互斥
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#使用信号量调度共享资源" class="md-nav__link">
    <span class="md-ellipsis">
      使用信号量调度共享资源
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用信号量调度共享资源">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#生产者-消费者问题" class="md-nav__link">
    <span class="md-ellipsis">
      生产者-消费者问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#读取者-写入者问题" class="md-nav__link">
    <span class="md-ellipsis">
      读取者-写入者问题
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#基于预线程的并发服务器" class="md-nav__link">
    <span class="md-ellipsis">
      基于预线程的并发服务器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#使用线程实现并行" class="md-nav__link">
    <span class="md-ellipsis">
      使用线程实现并行
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用线程实现并行">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#并行程序的性能指标" class="md-nav__link">
    <span class="md-ellipsis">
      并行程序的性能指标
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#其他并发问题" class="md-nav__link">
    <span class="md-ellipsis">
      其他并发问题
    </span>
  </a>
  
    <nav class="md-nav" aria-label="其他并发问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#线程安全" class="md-nav__link">
    <span class="md-ellipsis">
      线程安全
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#可重入" class="md-nav__link">
    <span class="md-ellipsis">
      可重入
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#竞争" class="md-nav__link">
    <span class="md-ellipsis">
      竞争
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#死锁" class="md-nav__link">
    <span class="md-ellipsis">
      死锁
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    CMU10-714：Deep Learning Systems
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            CMU10-714：Deep Learning Systems
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../cmu10-714/lecture2/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lecture2：ML Refresher / Softmax Regression
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../cmu10-714/lecture3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lecture3：Manual Neural Networks / Backprop
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../cmu10-714/lecture4/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lecture4：Automatic Differentiation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../cmu10-714/lecture5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lecture5：Automatic Differentiation Implementation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../cmu10-714/lecture6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Lecture6：Optimization
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../tools/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Tools
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Tools
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../life/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Life
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Life
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#使用进程实现并发" class="md-nav__link">
    <span class="md-ellipsis">
      使用进程实现并发
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用进程实现并发">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#基于进程的并发服务器" class="md-nav__link">
    <span class="md-ellipsis">
      基于进程的并发服务器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#进程的优缺点" class="md-nav__link">
    <span class="md-ellipsis">
      进程的优缺点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#使用-io-多路复用实现并发" class="md-nav__link">
    <span class="md-ellipsis">
      使用 I/O 多路复用实现并发
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用 I/O 多路复用实现并发">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#基于-io-多路复用的并发服务器" class="md-nav__link">
    <span class="md-ellipsis">
      基于 I/O 多路复用的并发服务器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io-多路复用的优缺点" class="md-nav__link">
    <span class="md-ellipsis">
      I/O 多路复用的优缺点
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#使用线程实现并发" class="md-nav__link">
    <span class="md-ellipsis">
      使用线程实现并发
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用线程实现并发">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#线程执行模型" class="md-nav__link">
    <span class="md-ellipsis">
      线程执行模型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#posix-线程" class="md-nav__link">
    <span class="md-ellipsis">
      Posix 线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#创建线程" class="md-nav__link">
    <span class="md-ellipsis">
      创建线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#终止线程" class="md-nav__link">
    <span class="md-ellipsis">
      终止线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#回收线程" class="md-nav__link">
    <span class="md-ellipsis">
      回收线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#分离线程" class="md-nav__link">
    <span class="md-ellipsis">
      分离线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#初始化线程" class="md-nav__link">
    <span class="md-ellipsis">
      初始化线程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#基于线程的并发服务器" class="md-nav__link">
    <span class="md-ellipsis">
      基于线程的并发服务器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#线程程序中的共享变量" class="md-nav__link">
    <span class="md-ellipsis">
      线程程序中的共享变量
    </span>
  </a>
  
    <nav class="md-nav" aria-label="线程程序中的共享变量">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#线程内存模型" class="md-nav__link">
    <span class="md-ellipsis">
      线程内存模型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#将变量映射到内存" class="md-nav__link">
    <span class="md-ellipsis">
      将变量映射到内存
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#共享变量" class="md-nav__link">
    <span class="md-ellipsis">
      共享变量
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#使用信号量同步线程" class="md-nav__link">
    <span class="md-ellipsis">
      使用信号量同步线程
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用信号量同步线程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#进度图" class="md-nav__link">
    <span class="md-ellipsis">
      进度图
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#信号量" class="md-nav__link">
    <span class="md-ellipsis">
      信号量
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#使用信号量实现互斥" class="md-nav__link">
    <span class="md-ellipsis">
      使用信号量实现互斥
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#使用信号量调度共享资源" class="md-nav__link">
    <span class="md-ellipsis">
      使用信号量调度共享资源
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用信号量调度共享资源">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#生产者-消费者问题" class="md-nav__link">
    <span class="md-ellipsis">
      生产者-消费者问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#读取者-写入者问题" class="md-nav__link">
    <span class="md-ellipsis">
      读取者-写入者问题
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#基于预线程的并发服务器" class="md-nav__link">
    <span class="md-ellipsis">
      基于预线程的并发服务器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#使用线程实现并行" class="md-nav__link">
    <span class="md-ellipsis">
      使用线程实现并行
    </span>
  </a>
  
    <nav class="md-nav" aria-label="使用线程实现并行">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#并行程序的性能指标" class="md-nav__link">
    <span class="md-ellipsis">
      并行程序的性能指标
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#其他并发问题" class="md-nav__link">
    <span class="md-ellipsis">
      其他并发问题
    </span>
  </a>
  
    <nav class="md-nav" aria-label="其他并发问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#线程安全" class="md-nav__link">
    <span class="md-ellipsis">
      线程安全
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#可重入" class="md-nav__link">
    <span class="md-ellipsis">
      可重入
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#竞争" class="md-nav__link">
    <span class="md-ellipsis">
      竞争
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#死锁" class="md-nav__link">
    <span class="md-ellipsis">
      死锁
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="并发编程">并发编程<a class="headerlink" href="#并发编程" title="Permanent link">&para;</a></h1>
<div style="margin-top: -30px; font-size: 0.75em; opacity: 0.7;">
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8V2m6.78 1a.69.69 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38-2.5-2.5Z"/></svg></span> 约 8428 个字 <span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3l89.3 89.4-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"/></svg></span> 590 行代码 <span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3L12.5 13Z"/></svg></span> 预计阅读时间 35 分钟</p>
</div>
<p>根据 Chapter8 介绍的内容，两个在时间上重叠的逻辑控制流是并发的。硬件异常处理程序、进程和 Linux 信号处理程序等都是计算机系统在不同层级上对并发的应用。现代操作系统为构建并发程序提供了三种基本方法：</p>
<ul>
<li>进程</li>
<li>I/O 多路复用（Multiplexing）</li>
<li>线程（Thread）</li>
</ul>
<h2 id="使用进程实现并发">使用进程实现并发<a class="headerlink" href="#使用进程实现并发" title="Permanent link">&para;</a></h2>
<p>构建并发程序最简单的方法是使用进程，如在父进程中接受客户端请求，然后创建子进程为客户端提供服务。</p>
<p>假设服务器在监听描述符<code>listenfd(3)</code>上接受来自客户端 1 的连接请求，并返回一个连接描述符<code>connfd(4)</code>：
<img alt="alt text" src="../image/image-164.png" />
服务器将调用<code>fork</code>创建一个子进程（下图中的“Child 1”），它获得服务器 <strong>描述符表</strong> 的完整副本。由于子进程不再需要监听描述符，而父进程不再需要连接描述符，我们应当将它们关闭：</p>
<p><img alt="alt text" src="../image/image-165.png" />
随后服务器接受来自客户端 2 的连接请求并返回一个新的连接描述符<code>connfd(5)</code>：</p>
<p><img alt="alt text" src="../image/image-166.png" />
服务器再次调用<code>fork</code>创建另一个子进程（下图中的“Child 2”）。此时，父进程正在等待下一个连接请求，两个子进程则并发地为各自的客户端提供服务：</p>
<p><img alt="alt text" src="../image/image-167.png" /></p>
<h3 id="基于进程的并发服务器">基于进程的并发服务器<a class="headerlink" href="#基于进程的并发服务器" title="Permanent link">&para;</a></h3>
<p>一个基于进程的并发服务器代码如下，其中第 32 行调用的<code>echo</code>函数来自于上一章介绍的 <a href="http://csapp.cs.cmu.edu/2e/ics2/code/netp/echo.c">echo.c</a>：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">echo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">connfd</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">sigchld_handler</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">WNOHANG</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="n">connfd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">socklen_t</span><span class="w"> </span><span class="n">clientlen</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_storage</span><span class="w"> </span><span class="n">clientaddr</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">Signal</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span><span class="w"> </span><span class="n">sigchld_handler</span><span class="p">);</span>
<span class="w">    </span><span class="n">listenfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">clientlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_storage</span><span class="p">);</span>
<span class="w">        </span><span class="n">connfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">SA</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Fork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Child closes its listening socket */</span>
<span class="w">            </span><span class="n">echo</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span><span class="w">    </span><span class="cm">/* Child services client */</span>
<span class="w">            </span><span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span><span class="w">   </span><span class="cm">/* Child closes connection with client */</span>
<span class="w">            </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">         </span><span class="cm">/* Child exits */</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Parent closes connected socket (important!) */</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>考虑到服务器将运行很长时间，我们需要安装一个 SIGCHLD 信号处理程序来回收子进程（第 4～9 行），详见 <strong>正确的信号处理</strong>。</p>
<p>父进程必须关闭<code>connfd</code>（第 36 行），否则连接描述符指向的 <strong>打开文件表条目</strong> 永远不会被释放，从而导致内存泄漏。子进程则不需要关闭<code>connfd</code>（第 33 行可以省略），因为它会在子进程退出时由内核自动关闭。</p>
<h3 id="进程的优缺点">进程的优缺点<a class="headerlink" href="#进程的优缺点" title="Permanent link">&para;</a></h3>
<p>父子进程共享打开文件表，但并不共享用户地址空间（虚拟内存），因此进程之间必须显式地使用 IPC（Interprocess Communications）机制来共享状态信息。由于进程控制和 IPC 的开销很高，基于进程的并发程序往往很慢。</p>
<h2 id="使用-io-多路复用实现并发">使用 I/O 多路复用实现并发<a class="headerlink" href="#使用-io-多路复用实现并发" title="Permanent link">&para;</a></h2>
<p>I/O 多路复用技术的基本思想是应用程序调用<code>select</code>函数监视多个文件描述符，等待一个或多个描述符准备好用于某种 I/O 操作。该函数十分复杂并有多种使用场景，这里我们只讨论 I/O 操作为读取的情况：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/select.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">fd_set</span><span class="w"> </span><span class="o">*</span><span class="n">fdset</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="c1">// Returns: nonzero count of ready descriptors, −1 on error</span>

<span class="c1">// Macros for manipulating descriptor sets</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="n">fd_set</span><span class="w"> </span><span class="o">*</span><span class="n">fdset</span><span class="p">);</span><span class="w">          </span><span class="cm">/* Clear all bits in fdset */</span>
<span class="n">FD_CLR</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">fd_set</span><span class="w"> </span><span class="o">*</span><span class="n">fdset</span><span class="p">);</span><span class="w">   </span><span class="cm">/* Clear bit fd in fdset */</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">fd_set</span><span class="w"> </span><span class="o">*</span><span class="n">fdset</span><span class="p">);</span><span class="w">   </span><span class="cm">/* Turn on bit fd in fdset */</span>
<span class="n">FD_ISSET</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">fd_set</span><span class="w"> </span><span class="o">*</span><span class="n">fdset</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Is bit fd in fdset on? */</span>
</code></pre></div>
<p>参数<code>fd_set</code>是一个描述符集，它在逻辑上是一个位向量（固定长度的 0，1 序列）：</p>
<div class="arithmatex">\[b_{n - 1},..., b_1, b_0\]</div>
<p>其中的每个位 <span class="arithmatex">\(b_k\)</span> 都对应了一个描述符 <span class="arithmatex">\(k\)</span>。当且仅当 <span class="arithmatex">\(b_k\)</span> 等于 1 时，描述符 <span class="arithmatex">\(k\)</span> 属于该描述符集。</p>
<p>在我们的应用场景中，参数<code>fd_set</code>是读取描述符集（Read Set），参数<code>n</code>是读取集的基数（Cardinality）。程序调用<code>select</code>函数后会一直阻塞，直到读取集中至少有一个描述符准备好被读取（即从该描述符中读取一个字节的请求不会阻塞）。</p>
<p>我们将读取集中已准备好被读取的描述符集合称为就绪集（Ready Set）。<code>select</code>函数会将<code>fdset</code>修改为就绪集，并返回就绪集的基数。因此，我们在每次调用该函数前都应当先更新读取集。</p>
<h3 id="基于-io-多路复用的并发服务器">基于 I/O 多路复用的并发服务器<a class="headerlink" href="#基于-io-多路复用的并发服务器" title="Permanent link">&para;</a></h3>
<p>一个基于 I/O 多路复用的并发服务器代码如下：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span>
<span class="p">{</span><span class="w">                                </span><span class="cm">/* represents a pool of connected descriptors */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">maxfd</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* largest descriptor in read_set */</span>
<span class="w">    </span><span class="n">fd_set</span><span class="w"> </span><span class="n">read_set</span><span class="p">;</span><span class="w">             </span><span class="cm">/* set of all active descriptors */</span>
<span class="w">    </span><span class="n">fd_set</span><span class="w"> </span><span class="n">ready_set</span><span class="p">;</span><span class="w">            </span><span class="cm">/* subset of descriptors ready for reading  */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nready</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* number of ready descriptors from select */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">maxi</span><span class="p">;</span><span class="w">                    </span><span class="cm">/* highwater index into client array */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">clientfd</span><span class="p">[</span><span class="n">FD_SETSIZE</span><span class="p">];</span><span class="w">    </span><span class="cm">/* set of active descriptors */</span>
<span class="w">    </span><span class="n">rio_t</span><span class="w"> </span><span class="n">clientrio</span><span class="p">[</span><span class="n">FD_SETSIZE</span><span class="p">];</span><span class="w"> </span><span class="cm">/* set of active read buffers */</span>
<span class="p">}</span><span class="w"> </span><span class="n">pool</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">byte_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* counts total bytes received by server */</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="n">connfd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">socklen_t</span><span class="w"> </span><span class="n">clientlen</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_storage</span><span class="w"> </span><span class="n">clientaddr</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">pool</span><span class="w"> </span><span class="n">pool</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">listenfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">init_pool</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pool</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Wait for listening/connected descriptor(s) to become ready */</span>
<span class="w">        </span><span class="n">pool</span><span class="p">.</span><span class="n">ready_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pool</span><span class="p">.</span><span class="n">read_set</span><span class="p">;</span>
<span class="w">        </span><span class="n">pool</span><span class="p">.</span><span class="n">nready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Select</span><span class="p">(</span><span class="n">pool</span><span class="p">.</span><span class="n">maxfd</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pool</span><span class="p">.</span><span class="n">ready_set</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* If listening descriptor ready, add new client to pool */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pool</span><span class="p">.</span><span class="n">ready_set</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">clientlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_storage</span><span class="p">);</span>
<span class="w">            </span><span class="n">connfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">SA</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
<span class="w">            </span><span class="n">add_client</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pool</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Echo a text line from each ready connected descriptor */</span>
<span class="w">        </span><span class="n">check_clients</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>该程序使用<code>pool</code>类型的结构体（第 3～12 行）保存活跃的客户端，并使用<code>init_pool</code>函数初始化客户端池（第 29 行）。在无限循环的每次迭代中，服务器调用<code>select</code>函数检测两种不同类型的输入事件：来自新客户端的连接请求；为现有客户端提供服务的连接描述符已准备好被读取。当连接请求到达时（第 38 行），服务器打开连接（第 41 行）并将新客户端加入到客户端池中（第 42 行）。最后，服务器调用<code>check_clients</code>函数向每个已连接的描述符写入文本行（第 46 行）。</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">init_pool</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="n">pool</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Initially, there are no connected descriptors */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">maxi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FD_SETSIZE</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">clientfd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Initially, listenfd is only member of select read set */</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">listenfd</span><span class="p">;</span>
<span class="w">    </span><span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">read_set</span><span class="p">);</span>
<span class="w">    </span><span class="n">FD_SET</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">read_set</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>init_pool</code>函数初始化客户端池。<code>p-&gt;clientfd</code>数组包含了所有已连接的描述符，一开始我们使用 -1 填充它（第 5～7 行）。此时<code>listenfd</code>是读取集<code>p-&gt;read_set</code>中唯一的描述符（第 10～12 行）。</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">add_client</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">connfd</span><span class="p">,</span><span class="w"> </span><span class="n">pool</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nready</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FD_SETSIZE</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="cm">/* Find an available slot */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">clientfd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Add connected descriptor to the pool */</span>
<span class="w">            </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">clientfd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">connfd</span><span class="p">;</span>
<span class="w">            </span><span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">clientrio</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">connfd</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Add the descriptor to descriptor set */</span>
<span class="w">            </span><span class="n">FD_SET</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">read_set</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Update max descriptor and pool highwater mark */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">connfd</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="p">)</span>
<span class="w">                </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">connfd</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">maxi</span><span class="p">)</span>
<span class="w">                </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">maxi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_SETSIZE</span><span class="p">)</span><span class="w"> </span><span class="cm">/* Couldn&#39;t find an empty slot */</span>
<span class="w">        </span><span class="n">app_error</span><span class="p">(</span><span class="s">&quot;add_client error: Too many clients&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>add_client</code>函数将一个新客户端添加到活跃客户端池中。如果<code>p-&gt;clientfd</code>数组中还有空位（第 6 行），该函数就将连接描述符<code>connfd</code>添加到该数组并初始化一个读取缓冲区以调用 <code>rio_readlineb</code>（第 9～10 行）。随后函数将连接描述符<code>connfd</code>添加到读取集（第 13 行），并更新客户端池的一些属性：变量<code>maxfd</code>代表<code>select</code>函数监视的最大文件描述符；变量<code>maxi</code>代表<code>p-&gt;clientfd</code>数组的最大索引（这样<code>check_clients</code>函数就不需要遍历整个数组）。</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">check_clients</span><span class="p">(</span><span class="n">pool</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">connfd</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
<span class="w">    </span><span class="n">rio_t</span><span class="w"> </span><span class="n">rio</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">maxi</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nready</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">connfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">clientfd</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">rio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">clientrio</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">        </span><span class="cm">/* If the descriptor is ready, echo a text line from it */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">connfd</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ready_set</span><span class="p">)))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nready</span><span class="o">--</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">MAXLINE</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">byte_cnt</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Server received %d (%d total) bytes on fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                       </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">byte_cnt</span><span class="p">,</span><span class="w"> </span><span class="n">connfd</span><span class="p">);</span>
<span class="w">                </span><span class="n">Rio_writen</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="cm">/* EOF detected, remove descriptor from pool */</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
<span class="w">                </span><span class="n">FD_CLR</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">read_set</span><span class="p">);</span>
<span class="w">                </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">clientfd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><code>check_clients</code>函数遍历客户端池中所有已就绪的连接描述符，如果从描述符中读取文本行成功（第 16 行），就将该行返回给客户端（第 18-21 行）。一旦客户端关闭连接且服务器检测到 EOF，服务器便关闭连接描述符（第 27 行）并将该描述符从读取集和客户端池中删除（第 28-29 行）。</p>
<p>I/O 多路复用的本质是将逻辑控制流建模为状态机（State Machines）：</p>
<p><img alt="alt text" src="../image/image-168.png" />
如上图所示，基于 I/O 多路复用的并发服务器为每个新客户端 <span class="arithmatex">\(k\)</span> 创建一个状态机 <span class="arithmatex">\(s_k\)</span> 并将其与连接描述符 <span class="arithmatex">\(d_k\)</span> 关联。每个状态机都有一个状态（等待描述符 <span class="arithmatex">\(d_k\)</span> 准备好被读取），一个输入事件（描述符 <span class="arithmatex">\(d_k\)</span> 已准备好被读取）和一个状态转换（从描述符 <span class="arithmatex">\(d_k\)</span> 中读取文本行）。</p>
<p>在示例的并发服务器中，<code>select</code>函数检测输入事件，<code>add_client</code>函数创建新的状态机（逻辑控制流）。<code>check_clients</code>函数通过读写文本行来执行状态转换，并在客户端发送完文本行后删除状态机。</p>
<h3 id="io-多路复用的优缺点">I/O 多路复用的优缺点<a class="headerlink" href="#io-多路复用的优缺点" title="Permanent link">&para;</a></h3>
<p>基于 I/O 多路复用的应用程序运行在单个进程的上下文中，因此每个逻辑控制流都可以访问整个进程的地址空间，这使得控制流之间共享数据变得非常容易。由于它不需要通过上下文切换管理新进程，程序的运行效率较高。像 Node.js、Nginx 和 Tornado 等现代高性能服务器均使用 I/O 多路复用实现。</p>
<p>I/O 多路复用的缺点是编码十分复杂，并且无法充分利用多核处理器。</p>
<h2 id="使用线程实现并发">使用线程实现并发<a class="headerlink" href="#使用线程实现并发" title="Permanent link">&para;</a></h2>
<p>线程是在进程上下文中运行的逻辑控制流，它由内核自动调度。每个线程都有自己的线程上下文，包括一个唯一的线程 ID（TID）、栈、栈指针、程序计数器、通用寄存器和条件码寄存器。在同一个进程内运行的所有线程共享该进程全部的虚拟地址空间。</p>
<h3 id="线程执行模型">线程执行模型<a class="headerlink" href="#线程执行模型" title="Permanent link">&para;</a></h3>
<p>线程的执行模型与进程类似：</p>
<p><img alt="alt text" src="../image/image-169.png" />
如上图所示，主线程（Main Thread）是进程生命周期的开始，它在某一时刻创建了一个对等线程（Peer Thread）。两线程同时运行，控制权通过上下文切换传递。</p>
<p>线程执行与进程的区别在于：</p>
<ul>
<li>线程上下文比进程上下文小得多，因此线程上下文切换比进程快；</li>
<li>属于同一进程的线程构成了一个对等池，它们没有父子层级结构。线程可以杀死任何对等线程或等待任何对等线程终止；</li>
<li>每个对等线程都可以读写相同的共享数据。</li>
</ul>
<h3 id="posix-线程">Posix 线程<a class="headerlink" href="#posix-线程" title="Permanent link">&para;</a></h3>
<p>Posix 线程（Pthread）是 C 程序操作线程的标准接口。它定义了大约六十个函数，允许程序创建线程、终止线程、回收线程、与对等线程安全地共享数据以及通知对等线程系统状态的变化等。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp/csapp.h&quot;</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">)</span><span class="w"> </span><span class="cm">/* thread routine */</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span>
<span class="w">  </span><span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>示例程序中，主线程创建了一个对等线程并等待它终止，对等线程在打印<code>Hello, world!\n</code>后返回。</p>
<p>线程的代码和局部数据封装在线程例程（Thread Routine）中，它将通用指针<code>void *</code>作为输入并返回另一个通用指针（第 2 行）。如果需要向线程例程传递多个参数，则应将它们放入一个结构体中并传递指向该结构体的指针。同样，如果想让线程例程返回多个参数，则应返回一个指向包含多个参数的结构体指针。</p>
<h3 id="创建线程">创建线程<a class="headerlink" href="#创建线程" title="Permanent link">&para;</a></h3>
<p>线程调用函数<code>pthread_create</code>创建新线程：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span><span class="w"> </span><span class="o">*</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="n">pthread_attr_t</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">,</span>
<span class="w">                   </span><span class="n">func</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="c1">// Returns: 0 if OK, nonzero on error</span>
</code></pre></div>
<p>参数<code>f</code>是新线程在其上下文中运行的例程，参数<code>arg</code>是该例程的输入参数。参数<code>attr</code>可用于更改新线程的默认属性，一般设为<code>NULL</code>。该函数返回时，参数<code>tid</code>将变为新线程的线程 ID。线程还可以调用<code>pthread_self</code>函数确认自己的线程 ID：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<span class="n">pthread_t</span><span class="w"> </span><span class="nf">pthread_self</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="c1">//Returns: thread ID of caller</span>
</code></pre></div>
<h3 id="终止线程">终止线程<a class="headerlink" href="#终止线程" title="Permanent link">&para;</a></h3>
<p>线程终止的方式包括：</p>
<ul>
<li>在其例程返回时隐式终止；</li>
<li>调用函数<code>pthread_exit</code>显式终止，参数<code>thread_return</code>用于函数 <code>pthread_join</code>：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">thread_return</span><span class="p">);</span>
<span class="c1">// Never returns</span>
</code></pre></div>
<ul>
<li>调用 Linux 函数<code>exit</code>终止进程以及与该进程关联的所有线程；</li>
<li>调用函数<code>pthread_cancel</code>终止另一个线程 ID 为<code>tid</code>的对等线程：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">pthread_cancel</span><span class="p">(</span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">);</span>
<span class="c1">// Returns: 0 if OK, nonzero on error</span>
</code></pre></div>
<h3 id="回收线程">回收线程<a class="headerlink" href="#回收线程" title="Permanent link">&para;</a></h3>
<p>线程调用<code>pthread_join</code>函数等待另一个线程<code>tid</code>终止：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">thread_return</span><span class="p">);</span>
<span class="c1">// Returns: 0 if OK, nonzero on error</span>
</code></pre></div>
<p>线程<code>tid</code>终止后，该函数将线程例程返回的通用指针分配到<code>thread_return</code>指向的位置，然后回收终止线程持有的所有内存资源。与  <code>waitpid</code> 不同，<code>pthread_join</code>只能等待某个特定线程终止。</p>
<h3 id="分离线程">分离线程<a class="headerlink" href="#分离线程" title="Permanent link">&para;</a></h3>
<p>在任意时刻，线程都是可连接的（Joinable）或分离的（Detached）。一个可连接的线程可以被其他线程回收或杀死，其内存资源（如栈）在它被另一个线程回收之前不会释放；相反，一个分离的线程无法被其他线程回收或杀死，其内存资源将在它终止时由系统自动释放。</p>
<p>默认情况下，线程是可连接的。为了避免内存泄漏，每个可连接的线程都应当被另一个线程显式地回收，或者调用<code>pthread_detach</code>函数成为一个分离的线程：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">pthread_detach</span><span class="p">(</span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">);</span>
<span class="c1">// Returns: 0 if OK, nonzero on error</span>
</code></pre></div>
<p>参数<code>tid</code>是被分离的线程 ID，线程可以将其设为<code>pthread_self()</code>来分离自己。</p>
<h3 id="初始化线程">初始化线程<a class="headerlink" href="#初始化线程" title="Permanent link">&para;</a></h3>
<p>线程调用<code>pthread_once</code>函数初始化与线程例程关联的状态：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<span class="n">pthread_once_t</span><span class="w"> </span><span class="n">once_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTHREAD_ONCE_INIT</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">pthread_once</span><span class="p">(</span><span class="n">pthread_once_t</span><span class="w"> </span><span class="o">*</span><span class="n">once_control</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">init_routine</span><span class="p">)(</span><span class="kt">void</span><span class="p">));</span>
<span class="c1">// Always returns 0</span>
</code></pre></div>
<p>参数<code>once_control</code>是一个全局变量或静态变量，它始终被初始化为<code>PTHREAD_ONCE_INIT</code>。该函数第一次被调用时会直接调用<code>init_routine</code>，随后使用相同<code>once_control</code>参数的调用不会起任何作用。如下示例程序将输出 1：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pthread.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="n">pthread_once_t</span><span class="w"> </span><span class="n">once_control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTHREAD_ONCE_INIT</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init_routine</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pthread_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">once_control</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">init_routine</span><span class="p">);</span>
<span class="w">    </span><span class="n">pthread_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">once_control</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">init_routine</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cnt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>当我们需要动态初始化多个线程共享的全局变量时，该函数十分有用。</p>
<h3 id="基于线程的并发服务器">基于线程的并发服务器<a class="headerlink" href="#基于线程的并发服务器" title="Permanent link">&para;</a></h3>
<p>一个基于线程的并发服务器代码如下：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">echo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">connfd</span><span class="p">);</span>
<span class="cm">/* thread routine */</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">connfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">vargp</span><span class="p">);</span>
<span class="w">    </span><span class="n">Pthread_detach</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">());</span>
<span class="w">    </span><span class="n">Free</span><span class="p">(</span><span class="n">vargp</span><span class="p">);</span>
<span class="w">    </span><span class="n">echo</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
<span class="w">    </span><span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">connfdp</span><span class="p">;</span>
<span class="w">    </span><span class="kt">socklen_t</span><span class="w"> </span><span class="n">clientlen</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_storage</span><span class="w"> </span><span class="n">clientaddr</span><span class="p">;</span>
<span class="w">    </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">listenfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">clientlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_storage</span><span class="p">);</span>
<span class="w">        </span><span class="n">connfdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">        </span><span class="o">*</span><span class="n">connfdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">SA</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
<span class="w">        </span><span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">connfdp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>程序的整体结构与基于进程的并发服务器类似，主线程反复等待客户端连接，然后创建对等线程处理请求。值得注意的是，该程序调用<code>Malloc</code>函数生成指向连接描述符的指针<code>connfdp</code>并将其传递给对等线程（第 32～34 行）。这是因为如果我们直接传递指针，如：</p>
<div class="highlight"><pre><span></span><code><span class="n">connfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">SA</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
<span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">connfd</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">connfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">vargp</span><span class="p">);</span>
<span class="w">    </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div>
<p>就会导致对等线程中的赋值语句与主线程中的<code>Accpet</code>调用产生竞争：若新客户端在赋值语句执行完毕前与服务器建立连接，则对等线程中的局部变量<code>connfd</code>会变成新客户端的连接描述符。由于<code>Malloc</code>可以将<code>connfd</code>动态分配到不同的堆内存 Block 中，这一问题便得到了解决。</p>
<p>为了避免内存泄漏，我们必须分离每个线程（第 8 行）并释放主线程分配的堆内存（第 9 行）。进程中的所有线程共享描述符表，连接描述符的<code>rfcnt</code>始终为 1。因此我们只需在对等线程中关闭连接描述符，而不必像基于进程的并发服务器那样在主线程进行同样的操作。</p>
<h2 id="线程程序中的共享变量">线程程序中的共享变量<a class="headerlink" href="#线程程序中的共享变量" title="Permanent link">&para;</a></h2>
<p>在程序员看来，线程的最大优势在于多个线程可以轻松地共享相同的程序变量。然而，这种便利可能会带来一些问题。为了正确地编写线程程序，我们以如下程序为例说明共享变量的含义及工作原理：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>
<span class="cp">#define N 2</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">);</span>

<span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">ptr</span><span class="p">;</span><span class="w"> </span><span class="cm">/* global variable */</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msgs</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="s">&quot;Hello from foo&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s">&quot;Hello from bar&quot;</span><span class="p">};</span>

<span class="w">    </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">msgs</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">Pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">vargp</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                                    </span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[%d]: %s (cnt=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myid</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">myid</span><span class="p">],</span><span class="w"> </span><span class="o">++</span><span class="n">cnt</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="线程内存模型">线程内存模型<a class="headerlink" href="#线程内存模型" title="Permanent link">&para;</a></h3>
<p>每个线程都有自己独立的线程上下文，因此多个线程之间共享同一进程上下文中的其余部分。它们包括：只读文本（代码）段、可读写数据段、堆、共享库和打开文件描述符等。</p>
<p>线程无法读取或写入另一个线程的寄存器，但任何线程都能够访问共享虚拟内存中的任何位置。尽管栈属于线程上下文的一部分，但线程可以使用指针对另一个线程的栈内容读取和写入。示例程序第 25 行，对等线程通过全局变量<code>ptr</code>间接引用了主线程栈中的数组<code>msgs[N]</code>。</p>
<h3 id="将变量映射到内存">将变量映射到内存<a class="headerlink" href="#将变量映射到内存" title="Permanent link">&para;</a></h3>
<p>C 线程程序根据变量的存储类型将其映射到虚拟内存：</p>
<ul>
<li>全局变量：全局变量的唯一实例在运行时位于 可读写段，它可以被任意线程引用。示例程序第 5 行声明的全局变量<code>ptr</code>便是如此；</li>
<li>局部自动变量：局部自动变量在运行时位于每个线程的栈中，如示例程序中的变量<code>tid</code>和<code>myid</code>。为了区分不同线程中的相同变量，我们将它们分别表示为<code>tid.m</code>、<code>myid.p0</code>和<code>myid.p1</code>；</li>
<li>局部静态变量：与全局变量一样，局部静态变量的唯一实例在运行时位于可读写段。即使示例程序中的每个对等线程都声明了局部静态变量<code>cnt</code>（第 24 行），在运行时虚拟内存中也只有一个<code>cnt</code>实例。</li>
</ul>
<h3 id="共享变量">共享变量<a class="headerlink" href="#共享变量" title="Permanent link">&para;</a></h3>
<p>当一个变量的实例被多个线程引用时，我们就称它为共享的。在示例程序中，变量<code>cnt</code>是共享的，而<code>myid</code>则不是。对等线程均通过<code>ptr</code>间接引用了局部变量<code>msgs</code>，因此<code>msgs</code>也是共享的。</p>
<h2 id="使用信号量同步线程">使用信号量同步线程<a class="headerlink" href="#使用信号量同步线程" title="Permanent link">&para;</a></h2>
<p>以下程序<code>badcnt.c</code>创建了两个对等线程，每个线程都会将全局共享变量<code>cnt</code>递增<code>niters</code>次：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Thread routine prototype */</span>

<span class="cm">/* Global shared variable */</span>
<span class="k">volatile</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Counter */</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">niters</span><span class="p">;</span>
<span class="w">    </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid1</span><span class="p">,</span><span class="w"> </span><span class="n">tid2</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Check input argument */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;usage: %s &lt;niters&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">niters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="w">    </span><span class="cm">/* Create threads and wait for them to finish */</span>
<span class="w">    </span><span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid1</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">niters</span><span class="p">);</span>
<span class="w">    </span><span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid2</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">niters</span><span class="p">);</span>
<span class="w">    </span><span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid1</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid2</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Check result */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cnt</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">niters</span><span class="p">))</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;BOOM! cnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cnt</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;OK cnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cnt</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Thread routine */</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">niters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">vargp</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">niters</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>理论上，该程序的输出结果应为<code>2 * niters</code>。然而当它在 Linux 系统上运行时，我们不但会得到错误的答案，并且每次的结果还不同：</p>
<div class="highlight"><pre><span></span><code>linux&gt;<span class="w"> </span>./badcnt<span class="w"> </span><span class="m">1000000</span><span class="w"> </span>BOOM!<span class="w"> </span><span class="nv">cnt</span><span class="o">=</span><span class="m">1445085</span>
linux&gt;<span class="w"> </span>./badcnt<span class="w"> </span><span class="m">1000000</span><span class="w"> </span>BOOM!<span class="w"> </span><span class="nv">cnt</span><span class="o">=</span><span class="m">1915220</span>
linux&gt;<span class="w"> </span>./badcnt<span class="w"> </span><span class="m">1000000</span><span class="w"> </span>BOOM!<span class="w"> </span><span class="nv">cnt</span><span class="o">=</span><span class="m">1404746</span>
</code></pre></div>
<p>为了清楚地理解这一问题，我们需要研究一下计数器循环（第 40～41 行）的汇编代码：</p>
<div class="highlight"><pre><span></span><code><span class="c1">; i in %rax, niters in %rcx, cnt in %rdx</span>
<span class="w">    </span><span class="nf">movq</span><span class="w">  </span><span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="nb">rcx</span>
<span class="w">    </span><span class="nf">testq</span><span class="w"> </span><span class="o">%</span><span class="nb">rcx</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rcx</span>
<span class="w">    </span><span class="nf">jle</span><span class="w">   </span><span class="nv">.L2</span>
<span class="w">    </span><span class="nf">movl</span><span class="w">  </span><span class="kc">$</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">eax</span>
<span class="nl">.L3:</span>
<span class="w">    </span><span class="nf">movq</span><span class="w">  </span><span class="nv">cnt</span><span class="p">(</span><span class="o">%</span><span class="nv">rip</span><span class="p">),</span><span class="w"> </span><span class="o">%</span><span class="nb">rdx</span>
<span class="w">    </span><span class="nf">addq</span><span class="w">  </span><span class="kc">$</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rdx</span>
<span class="w">    </span><span class="nf">movq</span><span class="w">  </span><span class="nv">movq</span><span class="w"> </span><span class="o">%</span><span class="nb">rdx</span><span class="p">,</span><span class="w"> </span><span class="nv">cnt</span><span class="p">(</span><span class="o">%</span><span class="nv">rip</span><span class="p">)</span>
<span class="w">    </span><span class="nf">addq</span><span class="w">  </span><span class="kc">$</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rax</span>
<span class="w">    </span><span class="nf">cmpq</span><span class="w">  </span><span class="o">%</span><span class="nb">rcx</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="nb">rax</span>
<span class="w">    </span><span class="nf">jne</span><span class="w">   </span><span class="nv">.L3</span>
<span class="nl">.L2:</span>
</code></pre></div>
<p>这段代码可以分为以下五个部分：</p>
<ul>
<li><span class="arithmatex">\(H_i\)</span>：循环头部的指令块（第 2～5 行）；</li>
<li><span class="arithmatex">\(L_i\)</span>：将变量<code>cnt</code>加载到寄存器 %<span class="arithmatex">\(rdx_i\)</span>（第 7 行）；</li>
<li><span class="arithmatex">\(U_i\)</span>：将 %<span class="arithmatex">\(rdx_i\)</span> 加一（第 8 行）；</li>
<li><span class="arithmatex">\(S_i\)</span>：将 %<span class="arithmatex">\(rdx_i\)</span> 更新后的值存回变量<code>cnt</code>（第 9 行）；</li>
<li><span class="arithmatex">\(T_i\)</span>：循环尾部的指令块（第 10～13 行）。</li>
</ul>
<p>上述指令在单核处理器上以某种顺序依次执行，不同的执行顺序将导致不同的结果。我们以第一次循环为例：</p>
<p><img alt="alt text" src="../image/image-170.png" />
如图（b）所示，线程 2 在第五步将变量<code>cnt</code>加载到 %<span class="arithmatex">\(rdx_2\)</span>。此时线程 1 已经在第三步更新了 %<span class="arithmatex">\(rdx_1\)</span> 的值，但还未把它存回<code>cnt</code>。因此 %<span class="arithmatex">\(rdx_2\)</span> 的初始值为 0，线程 2 无法像图（a）那样将<code>cnt</code>从 1 递增到 2。</p>
<h3 id="进度图">进度图<a class="headerlink" href="#进度图" title="Permanent link">&para;</a></h3>
<p>进度图（Progress Graph）将 n 个并发线程建模为 n 维笛卡尔空间中的轨迹（Trajectory）。其中，每个坐标轴对应线程 <span class="arithmatex">\(k\)</span> 的进度，每个点代表线程 <span class="arithmatex">\(k\)</span> 已完成指令 <span class="arithmatex">\(I_k\)</span> 的状态。程序<code>badcnt.c</code>第一次循环的进度图如下，点 <span class="arithmatex">\((L_1, S_2)\)</span> 代表线程 1 已完成 <span class="arithmatex">\(L_1\)</span>，线程 2 则已完成 <span class="arithmatex">\(S_2\)</span>：</p>
<p><img alt="alt text" src="../image/image-171.png" />
程序的执行历史可以用进度图中的轨迹表示。假设该程序第一次循环的指令执行顺序为：</p>
<div class="arithmatex">\[H_1, L_1, U_1, H_2, L_2, S_1, T_1, U_2, S_2, T_2\]</div>
<p>则进度图轨迹为：</p>
<p><img alt="alt text" src="../image/image-172.png" />
对于线程 <span class="arithmatex">\(i\)</span>，操作共享变量<code>cnt</code>的指令 <span class="arithmatex">\((L_i, U_i, S_i)\)</span> 构成了一个临界区（Critical Section），它不应当与其他线程的临界区相交。在进度图上，两线程临界区的交集构成了不安全区（Unsafe Region）：</p>
<p><img alt="alt text" src="../image/image-173.png" />
不安全区不包括其边缘，例如状态 <span class="arithmatex">\((H_1, H_2)\)</span> 和 <span class="arithmatex">\((S_1, U_2)\)</span> 均不属于该区域。绕过不安全区的轨迹被称为安全轨迹，而触及了不安全区中任何部分的轨迹都是不安全的。</p>
<h3 id="信号量">信号量<a class="headerlink" href="#信号量" title="Permanent link">&para;</a></h3>
<p>信号量（Semaphore）<code>s</code>是一个具有非负整数值的全局变量，我们只能对它进行两种操作：</p>
<ul>
<li><code>P(s)</code>：若<code>s</code>非零，则将其减一并立即返回；若<code>s</code>为零，则将线程暂停。当<code>s</code>变为非零且线程由<code>V</code>操作重启后，<code>P</code>再将<code>s</code>减一并把控制权返回给调用者；</li>
<li><code>V(s)</code>：将<code>s</code>加一。如果存在任何被<code>P</code>操作阻塞的线程，就随机重启它们中的一个。</li>
</ul>
<p><code>P(s)</code>和<code>V(s)</code>操作不可分割（具有原子性），因此它们不会被中断。其定义保证了正确初始化的信号量永远不会变为负值，我们将这种属性称为信号量的不变性（Semaphore Invariant）。</p>
<p>Posix 标准定义了多种操作信号量的函数：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;semaphore.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span><span class="w"> </span><span class="o">*</span><span class="n">sem</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pshared</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">);</span><span class="w">   </span><span class="cm">/* P(s) */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">);</span><span class="w">   </span><span class="cm">/* V(s) */</span>
<span class="c1">// Returns: 0 if OK, −1 on error</span>
</code></pre></div>
<p>每个信号量都必须在使用前初始化，<code>sem_init</code>函数则将信号量<code>sem</code>初始化为参数<code>value</code>。在我们的应用场景中，参数<code>pshared</code>始终为 0。线程分别调用<code>sem_wait</code>和<code>sem_post</code>函数来执行<code>P(s)</code>和<code>V(s)</code>操作。为了简洁起见，我们使用以下等效的包装函数代替：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">P</span><span class="p">(</span><span class="n">sem_t</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">);</span><span class="w">   </span><span class="cm">/* Wrapper function for sem_wait */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">V</span><span class="p">(</span><span class="n">sem_t</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">);</span><span class="w">   </span><span class="cm">/* Wrapper function for sem_post */</span>
<span class="c1">// Returns: nothing</span>
</code></pre></div>
<h3 id="使用信号量实现互斥">使用信号量实现互斥<a class="headerlink" href="#使用信号量实现互斥" title="Permanent link">&para;</a></h3>
<p>信号量提供了一种便捷的方法来确保线程对共享变量的访问互斥（Mutually Exclusive ）：将一个初始值为 1 的信号量与每个共享变量相关联，然后使用<code>P</code>和<code>V</code>操作包围临界区。</p>
<p>在这种情况下，信号量的值始终为 0 或 1，因此我们将它称为二进制信号量。用于实现互斥的二进制信号量通常被称为互斥锁（Mutex），对其进行<code>P</code>和<code>V</code>操作则分别被称为加锁和解锁。一个已被锁定但互斥锁还未被解锁的线程被称为持有互斥锁。</p>
<p>下图展示了我们如何使用二进制信号量正确同步程序<code>badcnt.c</code>，其中的每个状态都标注了该状态下信号量的值：</p>
<p><img alt="alt text" src="../image/image-174.png" />
图中信号量为 -1 的状态共同构成了禁止区（Forbidden Region）。由于信号量的不变性，任何可行的轨迹都无法进入该区域。禁止区完全包围了不安全区，因此轨迹也不会触及不安全区的任何部分。无论运行时指令执行的顺序如何，程序都会正确地递增<code>cnt</code>。</p>
<p>综上，为了使用信号量实现互斥，我们需要首先声明一个信号量<code>mutex</code>：</p>
<div class="highlight"><pre><span></span><code><span class="k">volatile</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Counter */</span>
<span class="n">sem_t</span><span class="w"> </span><span class="n">mutex</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Semaphore that protects counter */</span>
</code></pre></div>
<p>然后在主线程中将其初始化：</p>
<div class="highlight"><pre><span></span><code><span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="cm">/* mutex = 1 */</span>
</code></pre></div>
<p>最终在对等线程中调用<code>P</code>和<code>V</code>包围对共享变量<code>cnt</code>的更新操作：</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">niters</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">    </span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>
<h3 id="使用信号量调度共享资源">使用信号量调度共享资源<a class="headerlink" href="#使用信号量调度共享资源" title="Permanent link">&para;</a></h3>
<p>除了实现互斥之外，信号量的另一个重要作用是调度对共享资源的访问。在这种情况下，线程使用信号量与其他线程通信。让我们来看看两个经典案例：生产者-消费者（Producer-Consumer）问题和读取者-写入者（Readers-Writers）问题。</p>
<h4 id="生产者-消费者问题">生产者-消费者问题<a class="headerlink" href="#生产者-消费者问题" title="Permanent link">&para;</a></h4>
<p><img alt="alt text" src="../image/image-175.png" />
如上图所示，生产者和消费者线程共享一个有界缓冲区。生产者线程重复生成新项目并将它们插入缓冲区，消费者线程则不断从缓冲区中删除项目，然后消费（使用）它们。</p>
<p>由于插入和删除项目涉及到更新共享变量，我们必须保证线程对缓冲区的访问是互斥的。但仅仅保证互斥是不够的，我们还需要调度线程对缓冲区的访问：若缓冲区已满（没有空位），则生产者必须等待空位；若缓冲区为空（没有可用的项目），则消费者必须等待项目可用。</p>
<p>我们开发了一个名为 <span class="arithmatex">\(S_{buf}\)</span> 的简单包，它可以操作<code>sbuf_t</code>类型的缓冲区：</p>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Buffer array */</span><span class="w">         </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">             </span><span class="cm">/* Maximum number of slots */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">front</span><span class="p">;</span><span class="w">         </span><span class="cm">/* buf[(front+1)%n] is first item */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rear</span><span class="p">;</span><span class="w">          </span><span class="cm">/* buf[rear%n] is last item */</span>
<span class="w">    </span><span class="n">sem_t</span><span class="w"> </span><span class="n">mutex</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Protects accesses to buf */</span>
<span class="w">    </span><span class="n">sem_t</span><span class="w"> </span><span class="n">slots</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Counts available slots */</span>
<span class="w">    </span><span class="n">sem_t</span><span class="w"> </span><span class="n">items</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Counts available items */</span>
<span class="p">}</span><span class="w"> </span><span class="n">sbuf_t</span><span class="p">;</span>
</code></pre></div>
<p>所有项目均存储在一个动态分配且包含 <code>n</code> 个空位的整型数组<code>buf</code>中，<code>front</code>和<code>rear</code>用于记录数组中的第一个项目和最后一个项目。信号量<code>mutex</code>实现了对缓冲区访问的互斥，<code>slots</code>和<code>items</code>则分别计算缓冲区中的空位和可用项目的数量。</p>
<p><span class="arithmatex">\(S_{buf}\)</span> 包的实现如下：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sbuf.h&quot;</span>

<span class="cm">/* Create an empty, bounded, shared FIFO buffer with n slots */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">sbuf_init</span><span class="p">(</span><span class="n">sbuf_t</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Calloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span>
<span class="w">    </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">                       </span><span class="cm">/* Buffer holds max of n items */</span>
<span class="w">    </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">front</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Empty buffer iff front == rear */</span>
<span class="w">    </span><span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">      </span><span class="cm">/* Binary semaphore for locking */</span>
<span class="w">    </span><span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w">      </span><span class="cm">/* Initially, buf has n empty slots */</span>
<span class="w">    </span><span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">      </span><span class="cm">/* Initially, buf has zero data items */</span>
<span class="p">}</span>

<span class="cm">/* Clean up buffer sp */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">sbuf_deinit</span><span class="p">(</span><span class="n">sbuf_t</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Free</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Insert item onto the rear of shared buffer sp */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">sbuf_insert</span><span class="p">(</span><span class="n">sbuf_t</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">);</span><span class="w">                          </span><span class="cm">/* Wait for available slot */</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span><span class="w">                          </span><span class="cm">/* Lock the buffer */</span>
<span class="w">    </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[(</span><span class="o">++</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">rear</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Insert the item */</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span><span class="w">                          </span><span class="cm">/* Unlock the buffer */</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">);</span><span class="w">                          </span><span class="cm">/* Announce available item */</span>
<span class="p">}</span>

<span class="cm">/* Remove and return the first item from buffer sp */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">sbuf_remove</span><span class="p">(</span><span class="n">sbuf_t</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">items</span><span class="p">);</span><span class="w">                          </span><span class="cm">/* Wait for available item */</span>
<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span><span class="w">                          </span><span class="cm">/* Lock the buffer */</span>
<span class="w">    </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[(</span><span class="o">++</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">)];</span><span class="w">  </span><span class="cm">/* Remove the item */</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span><span class="w">                          </span><span class="cm">/* Unlock the buffer */</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">);</span><span class="w">                          </span><span class="cm">/* Announce available slot */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>sbuf_init</code>函数为缓冲区分配堆内存，将<code>front</code>和<code>rear</code>设为 0，并为三个信号量分配初始值；<code>sbuf_deinit</code>函数在程序使用完缓冲区后释放它；<code>sbuf_insert</code>函数等待一个可用的空位，然后锁定<code>mutex</code>，将项目添加到缓冲区尾部并解锁<code>mutex</code>，最后通知消费者线程新项目可用；<code>sbuf_remove</code>函数与之对称：当缓冲区中有项目可用时，它锁定<code>mutex</code>，然后移除缓冲区头部的项目并解锁<code>mutex</code>，最后通知生产者有新的空位。</p>
<h4 id="读取者-写入者问题">读取者-写入者问题<a class="headerlink" href="#读取者-写入者问题" title="Permanent link">&para;</a></h4>
<p>读取者-写入者问题是互斥问题的一般化。假设并发线程集合正在访问一个共享对象，如主存中的数据结构或磁盘上的数据库。写入者必须拥有对该对象的独占访问权，但读取者却可以与其他读取者共享。</p>
<p>我们可以根据读取者和写入者的优先级将这一问题分为两种情况：</p>
<ul>
<li>读取者优先：读取者不会因写入者在等待而等待；</li>
<li>写入者优先：一旦写入者准备好写入就尽快执行写入。</li>
</ul>
<p>示例程序展示了一个读取者优先的解决方案：</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Global variables */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">readcnt</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Initially = 0 */</span>
<span class="n">sem_t</span><span class="w"> </span><span class="n">mutex</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Both initially = 1 */</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">reader</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">        </span><span class="n">readcnt</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">readcnt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="cm">/* First in */</span>
<span class="w">            </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
<span class="w">        </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Critical section */</span>
<span class="w">        </span><span class="cm">/* Reading happens  */</span>

<span class="w">        </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">        </span><span class="n">readcnt</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">readcnt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="cm">/* Last out */</span>
<span class="w">            </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
<span class="w">        </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">writer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Critical section */</span>
<span class="w">        </span><span class="cm">/* Writing happens  */</span>

<span class="w">        </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>信号量<code>w</code>实现了对共享对象访问的互斥，<code>mutex</code>则保护了对共享变量<code>readcnt</code>（表示当前处于临界区的读取者数量）的访问。写入者每次进入临界区时都会锁定<code>w</code>并在离开时对其解锁。但只有第一个进入临界区的读取者才需要锁定<code>w</code>，只有最后一个离开临界区的读取者才需要解锁它。因此只要有一个读取者持有<code>w</code>（位于临界区），其他读取者就都可以畅通无阻地访问共享对象。</p>
<p>所有此类问题的解决方案都会导致饥饿（Starvation），即线程被阻塞并无法取得任何进展。例如在上述程序中，当读取者线程批量到达时，写入者只能无限期等待。</p>
<h3 id="基于预线程的并发服务器">基于预线程的并发服务器<a class="headerlink" href="#基于预线程的并发服务器" title="Permanent link">&para;</a></h3>
<p>前文介绍的 <strong>基于线程的并发服务器</strong> 需要为每个客户端创建一个新线程，因此其成本较高。基于预线程（Prethreading）的并发服务器可以通过生产者-消费者模型减少这一开销：</p>
<p><img alt="alt text" src="../image/image-176.png" />
如上图所示，主线程不断地接受来自客户端连接请求并在有界缓冲区中插入连接描述符。每个工作线程重复地从缓冲区中移除一个描述符并为客户端提供服务，然后等待下一个描述符。</p>
<p>我们使用 <span class="arithmatex">\(S_{buf}\)</span> 包实现这一模型：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sbuf.h&quot;</span>
<span class="cp">#define NTHREADS 4</span>
<span class="cp">#define SBUFSIZE 16</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">echo_cnt</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">connfd</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">);</span>

<span class="n">sbuf_t</span><span class="w"> </span><span class="n">sbuf</span><span class="p">;</span><span class="w"> </span><span class="cm">/* shared buffer of connected descriptors */</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="n">connfd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">socklen_t</span><span class="w"> </span><span class="n">clientlen</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_storage</span><span class="w"> </span><span class="n">clientaddr</span><span class="p">;</span>
<span class="w">    </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">listenfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="w">    </span><span class="n">sbuf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbuf</span><span class="p">,</span><span class="w"> </span><span class="n">SBUFSIZE</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NTHREADS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="cm">/* Create worker threads */</span>
<span class="w">        </span><span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">clientlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_storage</span><span class="p">);</span>
<span class="w">        </span><span class="n">connfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">SA</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
<span class="w">        </span><span class="n">sbuf_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbuf</span><span class="p">,</span><span class="w"> </span><span class="n">connfd</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Insert connfd in buffer */</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Pthread_detach</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">());</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">connfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sbuf_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbuf</span><span class="p">);</span><span class="cm">/* Remove connfd from buffer */</span><span class="w"> </span>
<span class="w">        </span><span class="n">echo_cnt</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span><span class="w">               </span><span class="cm">/* Service client */</span>
<span class="w">        </span><span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>在初始化缓冲区<code>sbuf</code>（第 25 行）之后，主线程创建了一组工作线程（第 26～27 行）。它进入无限循环，接受连接请求并将连接描述符插入到<code>sbuf</code>中。工作线程等待连接描述符可用后便将其从缓冲区中移除（第 42 行），然后调用<code>echo_cnt</code>函数为客户端提供服务。</p>
<p><code>echo_cnt</code>是上文提到的<code>echo</code>函数的变体，它将服务器接收到的字节数记录在全局变量<code>byte_cnt</code>中：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">byte_cnt</span><span class="p">;</span><span class="w"> </span><span class="cm">/* byte counter */</span>
<span class="k">static</span><span class="w"> </span><span class="n">sem_t</span><span class="w"> </span><span class="n">mutex</span><span class="p">;</span><span class="w">  </span><span class="cm">/* and the mutex that protects it */</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_echo_cnt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">byte_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">echo_cnt</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">connfd</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
<span class="w">    </span><span class="n">rio_t</span><span class="w"> </span><span class="n">rio</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">pthread_once_t</span><span class="w"> </span><span class="n">once</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTHREAD_ONCE_INIT</span><span class="p">;</span>

<span class="w">    </span><span class="n">Pthread_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">once</span><span class="p">,</span><span class="w"> </span><span class="n">init_echo_cnt</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">,</span><span class="w"> </span><span class="n">connfd</span><span class="p">);</span><span class="w">        </span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">MAXLINE</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">        </span><span class="n">byte_cnt</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;server received %d (%d total) bytes on fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">byte_cnt</span><span class="p">,</span><span class="w"> </span><span class="n">connfd</span><span class="p">);</span>
<span class="w">        </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">        </span><span class="n">Rio_writen</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>该函数使用<code>Pthread_once</code>（第 19 行）初始化信号量<code>mutex</code>和<code>byte_cnt</code>，于是我们便不必在主线程进行同样的操作了。这种方法使包更加易于使用，不过同时也增加了许多无用的工作（只有第一次调用<code>Pthread_once</code>是有意义的）。</p>
<h2 id="使用线程实现并行">使用线程实现并行<a class="headerlink" href="#使用线程实现并行" title="Permanent link">&para;</a></h2>
<p>到目前为止，我们对并发的研究仅局限于单核处理器。实际上并发程序往往在拥有多核处理器的机器上运行得更快，这是因为操作系统内核可以在多个 CPU 核心上并行调度线程。</p>
<p><img alt="alt text" src="../image/image-177.png" />
编写并行程序十分棘手，看似很小的代码更改却会对程序性能产生重大的影响。并行程序同步线程的开销非常高，因此我们需要尽量避免它，否则就可能出现线程数增加程序性能反而降低的问题。如果同步操作不可避免，则应当尽可能地增加有用计算以分摊其开销。</p>
<p>由于在同一个核心上切换多个线程的上下文会产生额外的开销，并行程序的线程数通常与机器的 CPU 核心数相同。</p>
<h3 id="并行程序的性能指标">并行程序的性能指标<a class="headerlink" href="#并行程序的性能指标" title="Permanent link">&para;</a></h3>
<p>加速比（Speedup）被定义为：</p>
<div class="arithmatex">\[S_p = \cfrac{T_1}{T_p}\]</div>
<p>其中，<span class="arithmatex">\(p\)</span> 是处理器核心的数量，<span class="arithmatex">\(T_p\)</span> 是程序在 <span class="arithmatex">\(p\)</span> 个核心上运行的时间。这个公式也被称为强缩放（Strong Scaling）。当 <span class="arithmatex">\(T_1\)</span> 是并行程序的顺序执行版本的运行时间时，<span class="arithmatex">\(S_p\)</span> 被称为绝对加速比；当 <span class="arithmatex">\(T_1\)</span> 是并行程序在一个核心上的运行时间时，<span class="arithmatex">\(S_p\)</span> 被称为相对加速比。绝对加速比比相对加速比更能真实地反映程序的性能，然而它也更难测量。尤其是一些复杂的并行程序，为其创建一个顺序执行的版本非常困难。</p>
<p>效率（Efficiency）被定义为：</p>
<div class="arithmatex">\[E_p = \cfrac{S_p}{p} = \cfrac{T_1}{pT_p}\]</div>
<p>该指标能够衡量程序并行化的开销，效率高的程序用于线程同步和通信的时间较少。</p>
<h2 id="其他并发问题">其他并发问题<a class="headerlink" href="#其他并发问题" title="Permanent link">&para;</a></h2>
<h3 id="线程安全">线程安全<a class="headerlink" href="#线程安全" title="Permanent link">&para;</a></h3>
<p>若一个函数被多个并发线程重复调用时总能生成正确的结果，我们就称它为线程安全的（Thread-safe）。反之，则为线程不安全函数。线程不安全函数可以分为以下四类：</p>
<ul>
<li>不保护共享变量的函数：上文提到的 <code>badcnt</code> 函数便属于此类。我们只需使用<code>P</code>和<code>V</code>等同步操作保护共享变量便可使函数线程安全，但同时也会增加程序的运行时间；</li>
<li>在多次调用中持续跟踪状态的函数：如伪随机数生成函数 <code>rand</code>，其当前调用的结果取决于上次迭代的中间结果。因此如果多个线程调用该函数，我们就无法确定返回的随机数序列。修改此类函数唯一的方法便是重写它们，使其不依赖任何<code>static</code>数据并让调用者通过参数来传递状态信息；</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">next_seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/* rand - return pseudo-random integer on 0..32767 */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">rand</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">next_seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_seed</span><span class="o">*</span><span class="mi">1103515245</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">12345</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="n">next_seed</span><span class="o">/</span><span class="mi">65536</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">32768</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* srand - set seed for rand() */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">srand</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_seed</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">next_seed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_seed</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<ul>
<li>返回指向<code>static</code>变量指针的函数：一些函数，如<code>ctime</code>和<code>gethostbyname</code>，在<code>static</code>变量中计算结果并返回指向该变量的指针。如果并发线程调用此类函数，一个线程正在使用的变量就有可能被另一个线程返回的结果覆盖。我们可以直接重写它们，但也可以在源码不可用或难以修改时使用锁定和复制（Lock-and-Copy）技术来解决线程不安全问题；</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">ctime_ts</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">time_t</span><span class="w"> </span><span class="o">*</span><span class="n">timep</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">privatep</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sharedp</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span><span class="n">P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">    </span><span class="n">sharedp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctime</span><span class="p">(</span><span class="n">timep</span><span class="p">);</span>
<span class="w">    </span><span class="n">strcpy</span><span class="p">(</span><span class="n">privatep</span><span class="p">,</span><span class="w"> </span><span class="n">sharedp</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Copy string from shared to private */</span>
<span class="w">    </span><span class="n">V</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">privatep</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>调用线程不安全函数的函数：如果函数<code>f</code>调用了第二类线程不安全函数<code>g</code>，那么<code>f</code>也是线程不安全的并且只能重写<code>g</code>；如果<code>g</code>是第一类或第三类函数，我们就可以使用互斥锁保护调用点和所有生成的共享数据以使<code>f</code>线程安全。在上面的例子中，虽然函数<code>ctime_ts</code>调用了线程不安全函数<code>ctime</code>，但它却是线程安全的。</li>
</ul>
<h3 id="可重入">可重入<a class="headerlink" href="#可重入" title="Permanent link">&para;</a></h3>
<p>可重入（Reentrant）函数是一种特殊的线程安全函数，它在被多个线程调用时不会引用任何共享数据。</p>
<p><img alt="alt text" src="../image/image-178.png" />
可重入函数不需要进行同步操作，因此通常比不可重入函数更高效。将第二类线程不安全函数重写为可重入函数是使其线程安全的唯一方法。我们可以将上节提到的函数<code>rand</code>修改为：</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* rand_r - a reentrant pseudo-random integer on 0..32767 */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">rand_r</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">nextp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">nextp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">nextp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1103515245</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">12345</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">nextp</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">65536</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">32768</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>其关键思想在于，<code>rand_r</code>使用被调用者传入的指针<code>nextp</code>代替了静态变量<code>next_seed</code>。</p>
<p>如果函数的所有参数都按值传递且所有的数据引用都指向局部自动变量，那么我们就称该函数是显式可重入的。无论该函数被调用的方式如何，其可重入性都不变；如果函数的某些参数通过引用（指针）传递且调用者线程小心地将非共享数据传递给指针，那么我们就称该函数是隐式可重入的，函数<code>rand_r</code>便是如此。</p>
<h3 id="竞争">竞争<a class="headerlink" href="#竞争" title="Permanent link">&para;</a></h3>
<p>当多个线程的执行顺序会影响程序的正确性时就会发生竞争，如：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;csapp.h&quot;</span>
<span class="cp">#define N 4</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pthread_t</span><span class="w"> </span><span class="n">tid</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* thread routine */</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vargp</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">vargp</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello from thread %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">myid</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>示例程序中，主线程创建了四个对等线程并将指向了唯一整数 ID 的指针<code>&amp;i</code>传递给它们。对等线程将参数传递的 ID 复制到局部变量（第 21 行），然后打印包含 ID 的消息。该程序看似简单，然而却输出了错误的结果：</p>
<div class="highlight"><pre><span></span><code><span class="n">linux</span><span class="o">&gt;</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">race</span>
<span class="n">Hello</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span>
<span class="n">Hello</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span>
<span class="n">Hello</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span>
<span class="n">Hello</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="mi">3</span>
</code></pre></div>
<p>出现这一问题的原因在于，主线程循环中变量<code>i</code>的自增（第 12 行）与对等线程中对参数的解引用和赋值（第 21 行）之间产生了竞争。如果对等线程在主线程变量<code>i</code>自增之后才执行第 22 行的代码，那么变量<code>myid</code>就变成了其他线程的 ID。</p>
<p>为了消除竞争，我们需要为每个 ID 动态分配一个堆内存 Block，并向线程传递指向该 Block 的指针。实际上，前文介绍的 <strong>基于线程的并发服务器</strong> 便使用了这一方法。</p>
<p>另一种方法是主线程直接向对等线程传递<code>i</code>而非其指针：</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span>
</code></pre></div>
<p>对等线程则将参数转换回<code>int</code>类型并赋给变量<code>myid</code>：</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">myid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">vargp</span><span class="p">;</span>
</code></pre></div>
<p>相比于第一种方法，这种方法的好处是减少了调用<code>malloc</code>和<code>free</code>带来的开销。但在类型转换中，它假设指针至少与整型一样大，可能不适用于某些操作系统。</p>
<h3 id="死锁">死锁<a class="headerlink" href="#死锁" title="Permanent link">&para;</a></h3>
<p>信号量的引入可能会导致线程被永远阻塞，我们将这种运行时错误称为死锁（Deadlock）。进度图是理解死锁的重要工具：</p>
<p><img alt="alt text" src="../image/image-179.png" /></p>
<p>上图中的两个线程使用信号量<code>s</code>和<code>t</code>实现互斥，但程序员错误地对<code>P</code>和<code>V</code>操作排序。一旦某个轨迹进入了死锁状态<code>d</code>，两信号量重叠的禁止区域便阻止了它所有的可行路线。换言之，由于每个阻塞线程等待的<code>V</code>操作永远不会被执行，程序发生死锁。</p>
<p>死锁是一个非常棘手的问题，因为它难以预测。程序可能正确地运行了上千次，但下一次便会出现死锁。更糟糕的是，并发程序每次执行的轨迹都有所不同，因此死锁还难以复现。</p>
<p>对于二进制信号量，我们可以使用互斥锁排序规则来防止死锁：若每个线程以相同的顺序加锁（如上图中两线程均先执行<code>P(s)</code>，再执行<code>P(t)</code>），则程序无死锁。解锁的顺序并不重要，因为<code>V</code>操作不会阻塞线程。</p>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2024-08-09T13:17:58+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2024-08-09</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2024-08-09T13:17:58+00:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2024-08-09</span>
  </span>

    
    
    
  </aside>


  



<div id="__comments">

<h3>颜色主题调整</h3>

<!-- <div class="tx-switch">
<button data-md-color-scheme="default"><code>default</code></button>
<button data-md-color-scheme="slate"><code>slate</code></button>
</div>

<script>
var buttons = document.querySelectorAll("button[data-md-color-scheme]")
buttons.forEach(function(button) {
        button.addEventListener("click", function() {
        var attr = this.getAttribute("data-md-color-scheme")
        document.body.setAttribute("data-md-color-scheme", attr)
        localStorage.setItem("data-md-color-scheme",attr);
        updateScheme();
        })
})
</script> -->

<div class="tx-switch">
<button class="button1" data-md-color-primary="red" style="background-color:red">red</button>
<button class="button1" data-md-color-primary="pink" style="background-color:pink;color:black">pink</button>
<button class="button1" data-md-color-primary="purple" style="background-color:purple">purple</button>
<button class="button1" data-md-color-primary="indigo" style="background-color:indigo">indigo</button>
<button class="button1" data-md-color-primary="blue" style="background-color:blue">blue</button>
<button class="button1" data-md-color-primary="cyan" style="background-color:cyan;color:black">cyan</button>
<button class="button1" data-md-color-primary="teal" style="background-color:teal">teal</button>
<button class="button1" data-md-color-primary="green" style="background-color:green">green</button>
<button class="button1" data-md-color-primary="lime" style="background-color:lime;color:black">lime</button>
<button class="button1" data-md-color-primary="orange" style="background-color:orange;color:black">orange</button>
<button class="button1" data-md-color-primary="brown" style="background-color:brown;border-radius=3px">brown</button>
<button class="button1" data-md-color-primary="grey" style="background-color:grey">grey</button>
<button class="button1" data-md-color-primary="black" style="background-color:black">black</button>
<button class="button1" data-md-color-primary="white" style="background-color:white;color:black">white</button>
</div>

<script>
var buttons = document.querySelectorAll("button[data-md-color-primary]")
buttons.forEach(function(button) {
        button.addEventListener("click", function() {
        var attr = this.getAttribute("data-md-color-primary")
        document.body.setAttribute("data-md-color-primary", attr)
        localStorage.setItem("data-md-color-primary",attr);
        })
})
</script>

<h2 ><!-- 评论 -->评论区~</h2>

有用的话请给我个赞和 star => <a href="https://github.com/Tangjp-wraith/Tangjp-wraith.github.io"><img alt="GitHub stars" src="https://img.shields.io/github/stars/Tangjp-wraith/Tangjp-wraith.github.io.svg?style=plastic&amp;label=Stars"></a>

</br>

快来跟我聊天~

</div>

<script src="https://giscus.app/client.js" data-repo="Tangjp-wraith/discussion" data-repo-id="R_kgDOLRJCPw"
    data-category="General" data-category-id="DIC_kwDOLRJCP84CdJdO" data-mapping="pathname" data-strict="0"
    data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="dark" data-lang="zh-CN"
    crossorigin="anonymous" async>
    </script>

<!-- Synchronize Giscus theme with palette -->
<script>
var giscus = document.querySelector("script[src*=giscus]")

/* Set palette on initial load */
var palette = __md_get("__palette")
if (palette && typeof palette.color === "object") {
    var theme = palette.color.scheme === "slate" ? "dark" : "light"
    giscus.setAttribute("data-theme", theme) 
}

/* Register event handlers after documented loaded */
document.addEventListener("DOMContentLoaded", function() {
    var ref = document.querySelector("[data-md-component=palette]")
    ref.addEventListener("change", function() {
    var palette = __md_get("__palette")
    if (palette && typeof palette.color === "object") {
        var theme = palette.color.scheme === "slate" ? "dark" : "light"
        localStorage.setItem("data-md-color-scheme", palette.color.scheme === "slate" ? "slate" : "default");
        /* Instruct Giscus to change theme */
        var frame = document.querySelector(".giscus-frame")
        frame.contentWindow.postMessage(
        { giscus: { setConfig: { theme } } },
        "https://giscus.app"
        )
    }
    })
})
</script>
                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      本页面的全部内容在 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a> 协议之条款下提供，附加条款亦可能应用
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.tabs", "content.code.annotate", "navigation.indexes", "navigation.top", "toc.follow"], "search": "../../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="../../../js/timeago.min.js"></script>
      
        <script src="../../../js/timeago_mkdocs_material.js"></script>
      
        <script src="../../../from_oi_wiki/js/extra.js"></script>
      
        <script src="../../../js/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../../../js/tablesort.js"></script>
      
        <script src="../../../termynal.js"></script>
      
    
  </body>
</html>