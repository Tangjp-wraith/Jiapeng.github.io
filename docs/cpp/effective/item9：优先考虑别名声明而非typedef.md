???+ example "item9"
    + `typedef`不支持模板化，但是别名声明支持。
    + 别名模板避免了使用“`::type`”后缀，而且在模板中使用`typedef`还需要在前面加上`typename`
    + C++14提供了C++11所有*type traits*转换的别名声明版本

### typename 关键字
用来澄清模板内部的一个标识符，代表的是某种类型

!!! reference
    《C++模板（第二版）》P62 《C++ Primer》P593

    当编译器遇到类似`T::xxx`这样的代码时，它不知道`xxx`是一个类型成员还是一个数据成员，直到实例化时自己才知道。
    但是为了处理模板，编译器必须知道名字是否表示一个类型，默认情况下C++会假定通过作用域运算符访问的名字不是类型


